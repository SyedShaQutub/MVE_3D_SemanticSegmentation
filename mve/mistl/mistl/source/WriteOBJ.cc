

//
//                 INTEL CORPORATION PROPRIETARY INFORMATION
//
//    This software is supplied under the terms of a license agreement or
//    nondisclosure agreement with Intel Corporation and may not be copied
//    or disclosed except in accordance with the terms of that agreement.
//    Copyright (C) 2014 Intel Corporation. All Rights Reserved.
//
//    ## specifics
//
//    Mistl - Multi-camera Image STructure Library
//	 @author Oliver Grau
//


#include	"mistl/Error.h"
#include	"mistl/TriangularMesh.h"
#include        "mistl/TextureMap.h"
#include <iostream>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <string>
#include <string.h>

 
namespace mistl {
  

void WriteOBJ( FILE *fp, const mistl::TriangularMesh &mesh, bool Y_axis_up ) 
{
  if(!mesh.plist.size()) return;
  
  // write point list
  fputs("\n# point list\n",fp);
  for(unsigned i=0; i<mesh.plist.size(); ++i) {
    const mistl::Vector3f &vp = mesh.plist[i];
    if(Y_axis_up ) {
            fprintf(fp,"v %g %g %g\n",
            vp[0], vp[2], -vp[1] );
    } else {
            fprintf(fp,"v %g %g %g\n",
            vp[0], vp[1], vp[2] );
    }
  }
  
  bool texture = (mesh.plist.size()==mesh.txtlist.size());
  bool normalsWritten= (mesh.plist.size()==mesh.normallist.size());
  
  if(texture) {
    fputs("\n# TextureBindings\n",fp);
    for(unsigned i=0; i<mesh.txtlist.size(); ++i) {
      const mistl::Vector2f &tp = mesh.txtlist[i];

      fprintf(fp,"vt %g %g %g\n", tp[0], tp[1], 0.0 );
    }
  }
  

  // write faces
  for(unsigned i=0; i<mesh.trilist.size(); ++i) {
    unsigned v1,v2,v3;
    v1=mesh.trilist[i].X()+1;
    v2=mesh.trilist[i].Y()+1;
    v3=mesh.trilist[i].Z()+1;
    if(texture) {
      if(normalsWritten)
        // f v1/vt1/vn1 v2/vt2/vn2 v3/vt3/vn3
        fprintf(fp,"f %u/%u/%u %u/%u/%u %u/%u/%u\n", v1,v1,v1, v2,v2,v2, v3,v3,v3 ) ;
      else
        // f v1/vt1 v2/vt2 v3/vt3
        fprintf(fp,"f %u/%u %u/%u %u/%u\n", v1,v1, v2,v2, v3,v3 ) ;
    } else {
      if(normalsWritten)
        // f v1//vn1 v2//vn2 v3//vn3
        fprintf(fp,"f %u//%u %u//%u %u//%u\n", v1,v1, v2,v2, v3,v3 ) ;
      else
        // f v1 v2 v3
        fprintf(fp,"f %u %u %u\n", v1, v2, v3 ) ;
    }

  }


}

void WriteOBJMaterial( FILE *fp, const mistl::TriangularMesh &mesh, const char *objfn )
{
  std::string  fn(objfn);
  size_t i = fn.rfind(".obj");
  
  if(i==  std::string::npos) fn+= ".mtl";
  else fn.replace(i,4,".mtl");
  
//   std::cout<<"Write material file:"<<fn;
  
  FILE *mat_of=fopen(fn.c_str(),"w");

  MISTL_ASSERT(fp, "WriteOBJ: error opening material file for writing");
  
  // entry in object file
  fprintf(fp,"\nmtllib %s\n", fn.c_str() );
  unsigned mapno=0;
  if(mesh.HasTextureMap() && mesh.map->filename.length()>0 )
          fprintf(fp,"\nusemtl %s\n",mesh.map->filename.c_str() );
  else
          fprintf(fp,"\nusemtl mat_%d\n",mapno);

  // entry in material file
  if(mesh.HasTextureMap() && mesh.map->filename.length()>0 )
          fprintf(mat_of,"newmtl %s\n",mesh.map->filename.c_str() );
  else
          fprintf(mat_of,"newmtl mat_%d\n",mapno);
  fputs("Ka 0.5 0.5 0.5\n",mat_of);
  fputs("Kd 1 1 1\n",mat_of);
  fputs("Ks 1 1 1\n",mat_of);
  fputs("Ns 4.0\n",mat_of);

  if(mesh.HasTextureMap()) {
    fprintf(mat_of,"map_Ka %s\n",mesh.map->filename.c_str() );
    fprintf(mat_of,"map_Kd %s\n",mesh.map->filename.c_str() );
  }
}


void WriteOBJ( const mistl::TriangularMesh &mesh, const char *fn, bool Y_axis_up) 
{

//   std::cout<<"Write obj fn:"<<fn; mesh.Info();
  
  FILE *fp=fopen(fn,"w");

  MISTL_ASSERT(fp, "WriteOBJ: error opening file for writing");


  fputs("# obj file generated by MISTL",fp);

  WriteOBJMaterial( fp, mesh, fn );
  WriteOBJ(fp,mesh,  Y_axis_up);
  
  fclose(fp);


}


void WriteOBJ( const std::vector<mistl::Vector3f>  &plist, const char *fn, float size, bool Y_axis_up=false ) {

  FILE *fp=fopen(fn,"w");

  MISTL_ASSERT(fp, "WriteOBJ: error opening file for writing");


  fputs("# obj file generated by MISTL",fp);

  for(unsigned i=0; i<plist.size(); ++i) {
    mistl::TriangularMesh *tp = mistl::CreateBox( plist[i],  size );
    WriteOBJ(fp,*tp,  Y_axis_up);
    delete tp;
  }
  
  fclose(fp);


}


	
}
